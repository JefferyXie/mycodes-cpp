#pragma once

#include "../core/header.h"

//
// pthread_self vs. gettid
/*
 *
 [pthread_self]

- The id is generated by the threading implementation and the id is process-wide
  unique as long as it's alive but can be reused if thread joined.
- In glibc, pthread_self() does not do system call, but returns a pointer to a
  struct pthread, located in the TSD segment.
- Returns a pointer to the vicinity of TLS (thread local storage) slot of the
  calling thread in the process memory map. This value is unique within a given
  process (and can be mapped to kernel TID and back), but it can not possibly be
  unique system wide, because every process has the same virtual address range.
- The pthread_equal(t1, t2) function is needed to compare thread ids because the
  pthread_t data type must be treated as opaque data.

 [gettid]

- The id is system-wide unique id and is generated by kernel.
- Returns a value corresponding to a thread's entry in the kernel process
  scheduler (very similar to what getpid() is perceived to be). This is something
  scheduling priorities and affinities can be set upon.
- There's overhead since it involves a system call.

 *
 * */

#include <pthread.h>
#include <linux/unistd.h>
#include <sys/syscall.h>

#ifndef gettid
// same as syscall(__NR_gettid))
#define gettid() syscall(SYS_gettid)
#endif

/*
output:
The id of thread1 is 18799
The id of thread1 is 3086543760
The id of thread2 is 18800
The id of thread2 is 3086543760
The id of thread3 is 18801
The id of thread3 is 3086543760
The id of thread4 is 18802
The id of thread4 is 3086543760
The id of thread5 is 18803
The id of thread5 is 3086543760

Explanation:
As you can see the ID generated by pthread_self() is reused by the threading
implementation after the thread completion which have achieved using the join
in the for loop..and the ID assigned by the kernel is unique one...
*/
void* printid(void* ptr)
{
    printf("The id of %s is %lu\n", (char*)ptr, gettid());
    printf("The id of %s is %u\n", (char*)ptr, (unsigned int)pthread_self());
    return 0;
}

void run_thread_id()
{
    pthread_t   thread[5];
    const char* msg[] = {"thread1", "thread2", "thread3", "thread4", "thread5"};
    for (int i = 0; i < 5; ++i) {
        pthread_create(&thread[i], NULL, printid, (void*)msg[i]);
        pthread_join(thread[i], NULL);
    }
    //    sleep(2000);
    //    for (int i = 0; i < 5; ++i) {
    //        pthread_join(thread[i], NULL);
    //    }
}

